\documentclass[11pt]{article}
\usepackage{fullpage}
\newif\ifanonymous
\anonymousfalse
\usepackage[T1]{fontenc}
\usepackage{tgbonum}


\usepackage{adjustbox}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{authblk}
\usepackage[advantage,
            adversary,
            asymptotics,
            complexity,
            ff,
            lambda,
            mm,
            operators,
            primitives,
            probability,
            sets]{cryptocode}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{todonotes}
\usepackage{csquotes}
\usepackage{tcolorbox}
\usepackage[binary-units]{siunitx}
\tcbuselibrary{theorems}

\usepackage[%dvips,
    pdftex,
    pdftitle={Proposal: Sigma-protocols},
    pdfauthor={Stephan Krenn and Michele Orrù}, pdfpagelabels=true, %linktocpage=true,     backref=page,
    bookmarks,bookmarksopen,bookmarksdepth=3,
    breaklinks,colorlinks,citecolor=blue,linkcolor=blue,urlcolor=blue
   ]{hyperref}
\usepackage[capitalize,nameinlink,sort]{cleveref}
\crefformat{equation}{(#2#1#3)}

\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{pifont}

\input{macros}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}

\newtcbtheorem{remark}{Remark}{
    colback=green!5,
    colframe=green!35!black,
    fonttitle=\bfseries}{th}

\newtcbtheorem{example}{Example}{
    colback=blue!5,
    colframe=blue!35!black,
    fonttitle=\bfseries}{th}


\title{A spec for $\Sigma$-protocols}
%
\date{Created on: \today}

\author{Michele Orrù, Stephan Krenn}
\begin{document}
%
\maketitle              % typeset the header of the contribution
%
{\hypersetup{hidelinks} \tableofcontents}

\section{Introduction}

Zero-knowledge~\cite{GolMicRac89} proofs of knowledge~\cite{C:BelGol92} allow a prover to convince a verifier that he knows a secret piece of information, without revealing anything else that what is already revealed by the claim itself.
Many practically relevant proof goals can be realized using so-called $\Sigma$-protocols, or their non-interactive counterparts, which can be proven secure in the random oracle model without the need for a common reference string.
Introduced by Schnorr~\cite{JC:Schnorr91} over 30 years ago, they are now widely used  in practice because of their simplicity, maturity, and versatility.

$\Sigma$-protocols played an essential component in the building of a number of cryptographic
constructions,
such as anonymous credentials~\cite{CCS:ChaMeiZav14}, password-authenticated key exchange~\cite{jpake}, signatures~\cite{C:Schnorr89},
ring signatures~\cite{borromeansig}, blind signatures~\cite{CCS:PoiSte97}, multi signatures~\cite{CCS:NRSW20}, threshold signatures~\cite{EPRINT:KomGol20} and more. This spec, initially proposed by Orrù and Krenn~\cite{sigma-proposal}, specifies guidelines for correctly implementing $\Sigma$-protocols.

\subsection{Notation}
\label{sec:notation}

For the purpose of this document, the following notation will be used:

\begin{tabular}{r@{\hspace{1em}}p{11cm}}
    $\secpar$ & main security parameter\\
    $\CS$ & challenge set, corresponding to a vector of 32 bytes (octets).\\
    $\statement$ & the statement, i.e., the public information in a zero-knowledge proof \\
    $\witness$ & the witness, i.e., the secret information in a zero-knowledge proof \\
    $\commitment$ & the first message, called commitment \\
    $\challenge$ & the second message, called challenge \\
    $\response$ & the third message, called response \\
    $x \defeq 1$ & assignment of the value 1 to $x$\\
    $x\sample\someset$ & assignment of a uniformly random element in $\someset$ to $x$\\
    $x\gets\alg(in)$ & assign to $x$ the output of the randomized procedure on input $in$\\
    $\relation$ & binary relation\\
    $|y|$ & bitlength of a string \\
    $\oplus$ & binary operator denoting the bitwise XOR of two strings of equal length
%    $\NN,\ZZ$ & non-negative natural numbers and integers, respectively
\end{tabular}

\subsection{Terminology}
A \emph{binary relation} $\relation$ associates elements from a set $\Set{Y}$ with elements from a set $\Set{W}$ through pairs $(\statement,\witness)\in\Set{Y}\times\Set{W}$.
For $(\statement,\witness)\in\relation$, we refer to $\statement$ as a \emph{statement}, and to $\witness$ as a \emph{witness} (for $\statement$).
Note there may be multiple witnesses for a given $\statement$.

\begin{example}{Discrete logarithm equality}{}
  Let $\GG$ be a cyclic group of prime order $p$, and let $G$ and $H$ be generators of $\GG$.
	Then the following relation $\relation$ contains as statements all pairs of elements having the same discrete logarithm with respect to $G$ and $H$, with the corresponding witness being their discrete logarithm:
  $$
	  \relation_{DLEQ} = \set{\left((\statement_1,\statement_2),\witness)\right)~:~\statement_1=\witness G ~\land~ \statement_2=\witness H}\,.
	$$
\end{example}

\begin{example}{Representation}{}
  Let $\GG$ be a cyclic group of prime order $p$, and let $G$ and $H$ be generators of $\GG$.
	Then the following relation $\relation$ contains as statements all valid Perdersen commitments, with the corresponding witnesses being their openings:
  $$
	  \relation_{REP} = \set{\left(\statement,(\witness_1,\witness_2))\right)~:~\statement=\witness_1G + \witness_2H}\,.
	$$
	Note that in this case, each statement has $p$ valid witnesses.
\end{example}

In a zero-knowledge proof, the \emph{witness} is secret information, while the statement is public.
A \emph{proof} is a sequence of bytes attesting that a witness is in some relation with the statement.

Proofs described in this spec are zero-knowledge and sound.
Zero knowledge means that the protocol does not leak any information about the prover's witness beyond what the attacker may infer from the proven statement or from other sources~\cite[1.6.4]{zkproof-reference}.
Soundness means that it is not possible to make the verifier accept for statements for which no valid witness exists~\cite[1.6.2]{zkproof-reference}.


%If soundness relies on computational assumption, then we call the proof an \emph{argument}.
%In particular we will focus on non-malleable simulation-extractable proofs.
%These protocols are proofs of knowledge~\cite{STOC:GolMicRac85,STOC:FeiFiaSha87,C:BelGol92} and are said to satisfy \emph{knowledge soundness}~\cite{damgard04}, which means that the prover must \emph{know} a witness in order to create a proof, mere \emph{existence} of a witness is not sufficient. 
%In addition, \emph{non-malleability} means that proofs cannot be modified without knowledge of a witness (similar to how strongly secure digital signatures cannot be modified by third parties). 
%Finally, \emph{simulation-extractability} means that when arguing about security, one can simultaneously, in the same argumentation, invoke the zero-knowledge property and the proof of knowledge property. 
%It is similar to how for digital signatures, one can argue that an attacker cannot create create a new signature even if they have seen some signatures before. 


\stnote{Add descriptions which protocols satisfy which security properties under which conditions}
%\jannote{Actually, some of the protocols mentioned here are not non-malleable simulation-extractable (say I do a proof for $\varphi(w_1,w_2) = g^{w_1 + w_2}$, for any $t\in\mathbb{F}_p$, I can always just add $c\cdot t$ to $s_1$ and subtract $c\cdot t$ from $s_2$, changing the proof but keeping it valid). In other words, not all proofs here have (quasi)unique responses}
%\jannote{Do security properties deserve their own section? Just throwing it out there. It may be interesting to talk about (1) under which circumstances proofs have non-malleability, what does it mean if they don't? (2) under what circumstances can I use these proofs (or do I need straight-line extractability for my application?). (3) What should I know about replay attacks? \\
%Also, we're currently implicitly assuming some properties that are not specified (as far as I can see); for example, ZK only holds if the announcement space is large enough; soundness only holds for large challenge spaces (which is an issue for, say, MPCitH). But there is no place to mention these right now. \\
%Such a section may be out of scope, I don't know, but it may be a good idea to warn people against doing stupid things. Alternatively, one could argue that one needs a trained cryptographer to design the proofs, anyway, and only focus on implementation aspects here.}

In particular we will focus on non-malleable extractable proofs, that is, the the witness does not only exist but it really must be known by the prover.
These protocols are also known as proofs of knowledge~\cite{STOC:GolMicRac85,STOC:FeiFiaSha87,C:BelGol92} and is said to satisfy \emph{knowledge soundness}~\cite{damgard04}. In addition, non-malleability means that the proof is secure against man-in-the middle attacks, and attackers that might change  then we call the proof \emph{simulation-extractable}.


\subsection{Scope of this document}

This document provides guidelines for secure implementations of $\Sigma$-protocols and is meant to facilitate adoption and the development of reference implementations.
This document is addressed to applied cryptographers and cryptographic engineers that are looking to implement a generic
$\Sigma$-protocol or provide an ad-hoc instantiation as part of a larger protocols.

We consider outside of this document the problem of having a high-quality
entropy source well-suited for crypto\-graphic purposes.
We will not talk about implementation of cryptographic primitives such as hash functions, or elliptic-curve algebra, but we will provide references to the algorithms.
We won't provide any guidance for securely storing secrets or producing constant-time code.

\minote{The problem of constant-time is for the most part in the OR composition}
\minote{People interested in the development of a specific $\Sigma$ protocol should implement the template from 2 using the algorithm from XX and XX and then refer to section XX}
\section{Generic $\Sigma$-Protocols}
In the following, we describe the class of $\Sigma$-protocols.
Such protocols can be used to prove that, for some binary relation $\relation$ and a public value $\statement$, a witness $\witness$ such that $(\statement,\witness)\in\relation$ is known.
Basic statements include proofs of knowledge of a secret key, openings of commitments, and more in general of representations.
The type of these elements depends on the specific relation being implemented.

All $\Sigma$-protocols involve three messages: a commitment, denoted $\commitment$; a challenge, denoted $\challenge$; a response, denoted $\response$.
In this document, the challenge is fixed to be a bitstring of $\seedlen$,
while the commitment and the response will depend on the specific protocol instantiation.

An important property of $\Sigma$-protocols is that they are composable: it is possible to prove conjunction and disjunctions of statements in zero-knowledge.
Composition of $\Sigma$-protocols is dealt in details in \cref{sec:composition}; for an in-depth discussion of the underlying theory we refer to Cramer~\cite{cramer97}.

\subsection{An abstract class for generic $\Sigma$-protocols}
The following formally describes the class of $\Sigma$-protocols, which covers all protocols considered in the remainder of this document.

Protocols studied in the remainder of this document will follow the same template class $\sigmaprotocol$, that will internally describe the relation being proven. These functions should be considered \emph{private} and \emph{should not} exposed externally.
Instances of $\sigmaprotocol$ are initialized via the $\new$ function, taking as input the statement $\statement$, while all other functions are to considered methods that acting on a particular $\sigmaprotocol$ instance.
A $\sigmaprotocol$ consists of the following methods:
\minote{I am not returning anything for elements that do not have a metavariable associated}
      \begin{itemize}
        \item $\sigmaprotocol.\new(\statement)$,
        denoting the initialization function. This function takes as input the statement $\statement$ shared during the execution of the protocol between prover and verifier.
        This function may pre-compute parts of the statement, or initialize the state of the hash function.
        \item
          $(\commitment, \proverstatett)\gets \sigmaprotocol.\provercommitment(\witness)$,
          denoting the \emph{commitment phase}, that is, the computation of the first message sent by the prover in a $\Sigma$-protocol. This method outputs a new commitment together with its associated prover state, depending on the witness known to the prover and the statement to be proven.
          This step generally requires access to a high-quality entropy source.
          Leakage of even just of a few bits of the nonce could allow for the complete recovery of the witness~\cite{lattice-attack,bleichenbacher,CCS:ANTTY20}.
					The value $\commitment$ is meant to be shared, while $\proverstatett$ must be kept secret.
          \minote{Why introduce the witness in this step? Because preprocessing the commitments before knowing the witness is not a great idea (where do you store them? Groth-Shoup attacks?) plus
          for dlog linear relations it seems helpful to have it around.}
        \item
          $\response \gets \sigmaprotocol.\proverresponse(\proverstatett, \challenge)$,
          denoting the \emph{response phase}, that is, the computation of the second message sent by the prover, depending on the witness, the statement, the challenge received from the verifier, and the internal state generated by $\provercommitment$.
          The value $\response$ is meant to be shared.
        \item $\sigmaprotocol.\verifiertt(\commitment, \challenge, \response)$,
          denoting the \emph{verifier algorithm}. This method checks that
          the \emph{protocol transcript} is valid for the given statement.
          The verifier algorithm outputs nothing if verification succeeds,
          or an error if verification fails.
          \item $\sigmaprotocol.\labeltt()$,
          returning a string of $\seedlen$ uniquely identifying the relation being proven.
          Implementing correctly this function is vital security, and one \emph{must} carefully follow the directives written in the relative instantiations. It is crucial for security that the label includes all data available in the statement, including the parameters and the relation being proven.

          More precisely, if the label is \emph{not} tied to the relation, then it may be possible to produce another proof for a different relation without knowing its witness.
          Similarly, if the statement is not tied to the statement, then it might be possible to produce proofs
          for another statement whose witness is related to the original proof.

        \item $\response \gets \sigmaprotocol.\simresponsett()$,
        denoting the first stage of the \emph{simulator}. It is an algorithm drawing a random response that follows the same output distribution of the algorithm $\proverresponse$.
        \item $\commitment \gets \sigmaprotocol.\simcommitmenttt(\challenge, \response)$, denoting the second stage of the \emph{simulator}, returning a commitment that follows the same output distribution of the algorithm $\provercommitment$.
      \end{itemize}
      \stnote{are there any reasonable $\Sigma$-protocols where the simulator cannot be split like this? e.g., are there any protocols where $\challenge$ and $\response$ do not uniquely determine $\commitment$ (which would maybe mean that the short form of fiat-shamir does not work anyways)?}
      \jannote{@Stephan: Afaik, pretty much every simulator can be split into \enquote{choose random $\response$, then choose (random) fitting $\commitment$}.
      There \emph{are} notable examples where $\challenge, \response$ do not \emph{uniquely} determine $\commitment$ (and hence cannot do short-form Fiat-Shamir as it's defined right now).
      (1) MPC in the head proofs (ZKBoo is cited in Section 4). (2) \cite[Fig 1]{EC:GroKoh15} (also cited in Section 4). (3) any send-randomized-signature-then-prove protocols like \cite[Section 6.2]{EPRINT:PoiSan15} or \cite[Fig 1]{AC:CamChaShe08}. \\
      As noted in \cite[Observation 1]{EC:GGHK22}, one can force the unique-announcement property by including the announcement in the response, though that clearly negates the benefits of short-form FS.
      To suggest a way out: in our implementation \cite{EPRINT:BEHF21}, to enable short-form FS for all Sigma protocols, we add compress/decompress methods to the Sigma protocol interface. 
      %https://github.com/cryptimeleon/craco/blob/489448105453940d686f5fa159832d35d74af19f/src/main/java/org/cryptimeleon/craco/protocols/arguments/sigma/SigmaProtocol.java#L111
      Compress takes a transcript $(\commitment, \challenge, \response)$ and outputs a shorter version of it (e.g., just $\response$ or something like $(\sigma, \response)$ if the announcement contains some part $\sigma$ that cannot be uniquely recomputed from $(\challenge, \response)$). Decompress takes the compressed transcript and a challenge and outputs an error or the unique accepting full transcript. Then short-form FS becomes $(\challenge, \mathit{compressed\ transcript})$.}
      \minote{there are some invariants that these protocols should satisfy:
      checking the output distribution might be hard, but trivially all simulated transcripts (as well as honest transcripts) should verify! }
    % \begin{protocol}{Generic flow of a $\Sigma$-protocol.\\[-2.25em]}{fig:generic}{t}
    %   \begin{tabular}{@{}l@{\hspace{-2em}}c@{\hspace{-2em}}r@{}}
    %     & $\sigmaprotocol.\new(\statement)$  \\
    %     \hline  \\
    %   % -----------------------------P1-------------------------------
    %     $(\commitment,\proverstatett) \gets \provercommitment()$\\
    %     & $\sendr{\commitment}{100}$ \\[2 ex]
    %   % -----------------------------CHALLENGE-------------------------------
    %     & & $\challenge \sample \CS$ \\
    %     & $\sendl{\challenge}{100}$ & \\[2 ex]
    %   % -----------------------------P2-------------------------------
    %     $ s \gets \proverresponse(\proverstatett,\challenge)$\\
    %     & $\sendr{\response}{100}$ \\[2 ex]
    %   % -----------------------------V-------------------------------
    %     & & $\accept/\reject \gets \verifiertt(\commitment,\challenge,\response)$ \\
    %   \end{tabular}
    % \end{protocol}



\begin{remark}{Computing the challenge}{}
  The interactive versions of the $\Sigma$-protocols presented in this document are not fit for practical applications, due to subtle yet impactful details in their security guarantees.
%git For those applications where latency is not a problem, we direct the reader towards~\cref{XXX} for general techniques.
 For practical applications, their non-interactive versions---as described in \cref{sec:fs}---shall be used.
\end{remark}


\subsection{Composition of $\Sigma$-Protocols}
\label{sec:composition}
\label{sec:or-comp}
\label{sec:and-comp}
  In this section, we specify composition techniques of $\Sigma$-protocols.

  Specifically, we define mechanisms for proving knowledge of multiple independent witnesses (\emph{AND composition}), and for proving knowledge for one out of a set of witnesses (\emph{OR composition}). The $\sigmaprotocol$ object is a recursive enumeration of the following form:

  \begin{verbatim}
    enum SigmaProtocol {
      AndComposition {left: SigmaProtocol, right: SigmaProtocol},
      OrComposition  {left: SigmaProtocol, right: SigmaProtocol},
      [...]
    }
  \end{verbatim}

The dots \texttt{[...]} denote optional, specific $\Sigma$ protocol instantiations that will be covered in \cref{sec:sigma-dlog}.
  Without loss of generality, the techniques presented in the following focus on the composition of two protocols. 
  Composition of multiple protocols (e.g., proving knowledge of a witness for one out of many statements) can be achieved by recursively applying composition of two protocols.

  \subsubsection{AND Composition}
  In the following we explain how to construct a $\Sigma$-protocol proving knowledge of multiple independent witnesses, e.g., knowledge of multiple secret keys, or openings to multiple commitments.
  That is, the algorithms specified below constitute a $\Sigma$-protocol for the following relation:
\[
  \relation^\land = \set{
    ((\statement^0,\statement^1),(\witness^0,\witness^1) : (\statement^0,\witness^0)\in \relation^0 ~\land~ (\statement^1,\witness^1)\in\relation^1}
\]
For the rest of this section, the witness $\witness$ for the $\Sigma$-protocol will now be a pair $(\witness^0, \witness^1)$ of witnesses, and the associated statement $\statement$ will be a pair $(\statement^0, \statement^1)$ of statements, where $\witness^0$ is the witness for the statement $\statement^0$, and $\witness^1$ is the witness for $\statement^1$.
%\minote{say explicitly that now the witness is a pair of witnesses valid for the respective relation. Same goes for the statement}

  Intuitively, the AND composition simply runs the instances of the different protocols to be composed in parallel, using the same challenge $\challenge$ for all instances.
  The verifier will then accept the protocol run, if and only if all instances of the partial protocols output $\accept$.
  \begin{remark}{Witness equality}{}
  Note that the AND-composition defined in the following gives no guarantee about equality of the witnesses: if the same witness is used across different clauses of the AND-composition, the protocol will not guarantee that they are indeed the same.
	How to achieve such claims is discussed in \cref{sec:linear_relations}.
  \end{remark}

The main procedures of the resulting $\Sigma$-protocol are specified by the following algorithms:
\begin{itemize}
  \item
  $\andcomposition.\new(\leftbranch, \rightbranch)$: internally store $\leftbranch$ and $\rightbranch$.
  \item
  $(\vec \commitment, \proverstatett)\gets \andcomposition.\provercommitment(\vec \witness)$
    \begin{enumerate}
      \item
        $(\witness^0,\witness^1)\defeq \vec \witness$
      \item
        $(\commitment^0,\proverstatett^0)\gets\leftbranch.\provercommitment(\witness^0)$
      \item $(\commitment^1,\proverstatett^1)\gets\rightbranch.\provercommitment(\witness^1)$
      \item
	Return $(\vec \commitment,\proverstatett) \defeq ((\commitment^0,  \commitment^1),(\proverstatett^0,\proverstatett^1))$
    \end{enumerate}
  \item
  $\vec \response \gets \andcomposition.\proverresponse(\proverstatett, \challenge)$
  \begin{enumerate}
      \item
	    $(\proverstatett^0,\proverstatett^1)\defeq \proverstatett$
      \item
      $\response^0\gets\leftbranch.\proverresponse(\proverstatett^0, \challenge)$
      \item
      $\response^1\gets\rightbranch.\proverresponse(\proverstatett^1, \challenge)$
      \item
      Return $\vec \response\defeq(\response^0,\response^1)$
    \end{enumerate}
  \item
  $\andcomposition.\verifiertt(\vec \commitment, \challenge, \vec \response)$
  \begin{enumerate}
      \item
        $(\response^0,\response^1)\defeq \vec \response$.
      \item
	Return $\accept$ if both $\leftbranch.\verifiertt(\commitment^0,\challenge, \response^0)$ and $\rightbranch.\verifiertt(\commitment^1,\challenge, \response^1)$ return $\accept$. Otherwise, return $\reject$.
    \end{enumerate}
  \item  $\andcomposition.\labeltt()$ is computed as:
    \[
     \hash(\andlabel \concat \leftbranch.\labeltt() \concat \rightbranch.\labeltt())
   \]
   The supported hash functions are described in \cref{sec:hash-registry}.
   \minote{in particular we want those strings to be always 32B and padded with zeros}
  \item
  $\vec \response \gets \andcomposition.\simresponsett()$
   generates a simulated response as follows:
    \begin{enumerate}
      \item
        $\response^0\gets\leftbranch.\simresponsett()$
        \item $\response^1\gets\rightbranch.\simresponsett()$
      \item
        Return $\vec \response\defeq(\response^0,\response^1)$.
    \end{enumerate}
  \item
  $\vec \commitment \gets \andcomposition.\simcommitmenttt(\challenge, \vec \response)$ works as follows:
    \begin{enumerate}
      \item
        $(\response^0,\response^1)\defeq\vec\response$.
      \item
        $\commitment^0\gets\leftbranch.\simcommitmenttt(\challenge,\response^0)$
        \item $\commitment^1\gets\rightbranch.\simcommitmenttt(\challenge,\response^1)$
      \item
        Return $\vec \commitment\defeq(\commitment^0, \commitment^1)$.
      \end{enumerate}
\end{itemize}



\subsubsection{OR Composition}
\minote{It is not immediate to build OR composition in  constant-time. It is possible to double the cost and run prover and simulator for each branch, but at the end we still need the ternary operator to select the correct transcirpt. This is the only place where we are incurring in non non-constant-time operations assuming the algebraic operations are already solved. }
  In the following we explain how to construct a $\Sigma$-protocol proving knowledge of one out of a set of witnesses, e.g., one of a set of secret keys in the case of ring signatures.
  That is, the algorithms specified below constitute a $\Sigma$-protocol for the following relation:
\[
  \relation^\lor = \set{
    ((\statement^0,\statement^1),(\witness^0,\witness^1) :
    (\statement^0,\witness^0)\in \relation^0 ~\lor~ (\statement^1,\witness^1)\in\relation^1}\,.
\]
\minote{Say explicitly that now the witnesses are a pair of optional arugments, at least one of them being a non-null witness.}
  In the following protocol specification, let $j$ be such that $w^j$ is known to the prover, whereas without loss of generality $\witness^{1-j}$ is assumed to be unknown to the prover.

	On a high level, the protocol works as follows.
	Using the simulator, the prover first simulates a transcript for the unknown witness (keeping the challenge and response of this transcript temporarily secret), and generates an honest commitment for the known witness.
	Having received the challenge, the prover then computes challenge for the known witness, depending on the received challenge and the one from the simulated transcript.
	Having computed the response, the prover transfers the responses of both transcripts, as well as the partial challenges to the verifier, who accepts if and only if both instances of the partial protocols output $\accept$ and the partial challenges correctly add up to the random challenge.

The main procedures of the resulting $\Sigma$-protocol are specified by the following algorithms:
\begin{itemize}
  \item
  $\orcomposition.\new(\leftbranch, \rightbranch)$: internally store $\leftbranch$ and $\rightbranch$.
  \item
  $(\vec \commitment, \proverstatett)\gets \orcomposition.\provercommitment(\vec \witness)$:
    \begin{enumerate}
      \item $\provertt = [\leftbranch, \rightbranch]$
      \item
        $(\witness^0,\witness^1)\defeq \vec \witness$, and let $j \in \bin$ be the first index for which $\witness^{j}\neq\none$
      \item
        $(\commitment^j,\proverstatett)\gets\provertt[j].\provercommitment(\statement^j,\witness^j)$
      \item
			   $\response^{1-j}\gets\provertt[1-j].\simresponsett()$
			\item
        Choose a random $\challenge^{1-j}$ in $\CS$
      \item
        $\commitment^{1-j}\gets\provertt[1-j].\simcommitmenttt(\challenge^{1-j},\response^{1-j})$
      \item
	Return $(\vec \commitment,\proverstatett) \defeq ((\commitment^0,\commitment^1),(\proverstatett,\challenge^{1-j},\response^{1-j}))$
    \end{enumerate}
  \item
  $\vec \response \gets \orcomposition.\proverresponse(\proverstatett, \challenge)$:
    \begin{enumerate}
      \item  $(\proverstatett^j,\challenge^{1-j},\response^{1-j})\defeq\proverstatett$
      \item
         $\challenge^j\defeq \challenge\oplus \challenge^{1-j}$
         \item $\response^j\gets\provertt[j].\proverresponse(\proverstatett, \challenge^j)$
      \item
        Return $\vec \response\defeq(\response^0,\response^1, \challenge^0)$.
    \end{enumerate}
  \item
  $\orcomposition.\verifiertt(\vec \commitment, \challenge, \vec \response)$,
    \begin{enumerate}
      \item
         $(\response^0, \response^1, \challenge^0)\defeq \vec \response$.
      \item
         $\challenge^1\defeq \challenge \oplus \challenge^0$.
      \item
	    Return $\pctrue$ if both $\leftbranch.\verifiertt(\commitment^0,\challenge^0,\response^0)$ and $\rightbranch.\verifiertt^1(\commitment^1,\challenge^1,\response^1)$ return $\pctrue$. Otherwise, return $\pcfalse$.
    \end{enumerate}
  \item  $\orcomposition.\labeltt()$ is computed as:
    \[
     \hash(\orlabel \concat \leftbranch.\labeltt() \concat \rightbranch.\labeltt())
   \]
   The supported hash functions are described in \cref{sec:hash-registry}.
  \item
  $\vec \response \gets \orcomposition.\simresponsett()$
    \begin{enumerate}
      \item
         $(\statement^0,\statement^1)\defeq \vec \statement$.
      \item
         $\response^0\gets\leftbranch.\simresponsett()$
      \item $\response^1\gets\rightbranch.\simresponsett()$
      \item
        Choose a random $\challenge^0$ in $\CS$.
			\item
        Return $\vec \response \defeq (\response^0,\response^1,\challenge^0)$.
    \end{enumerate}
\item
$\vec \commitment \gets \orcomposition.\simcommitmenttt(\challenge, \vec \response)$ works as follows:
\begin{enumerate}
      \item
        $(\response^0,\response^1,\challenge^0)\defeq\vec\response$.
      \item
        $\challenge^1\defeq \challenge \oplus \challenge^0$.
      \item
        $\commitment^0 \gets\leftbranch.\simcommitmenttt(\challenge^0,\response^0)$
    \item $\commitment^1\gets\rightbranch.\simcommitmenttt(\challenge^1,\response^1)$
      \item
        Return $\vec \commitment \defeq (\commitment^0,\commitment^1)$.
    \end{enumerate}
\end{itemize}


\subsection{The Fiat-Shamir Transform}\label{sec:fs}
% \marynote{Considering you are stressing the importance of hashing the instance, I would send the instance in the first message of the interactive versions as well.}
All protocols described in this standard require three messages being exchanged between the prover and the verifier.
In practice, public-coin protocols such as $\Sigma$-protocols can be converted into non-interactive ones through the
Fiat and Shamir heuristic~\cite{C:FiaSha86} and subsequent work, e.g., by Bernhard et al.~\cite{AC:BerPerWar12}

The underlying idea is to replace the verifier with a cryptographically secure hash function, hashing the context from the protocol and the previous message sent by the prover.

\begin{remark}{Interactive $\Sigma$-protocols}{} The interactive version of $\Sigma$-protocols presented in this paper is unfit for practical applications.
\end{remark}

\subsubsection{Hash Registry}
\label{sec:hash-registry}.

We support all of the following hash functions that takes as input a sequence of bytes of arbitrary length and output $\seedlen$ of entropy.

\begin{center}
  \begin{tabular}{lll}
  Hash & Security Level & Source \\
  \hline
  Blake2 \\
  Keccak & \\
  \unsure{Poseidon} &\\
  \end{tabular}
\end{center}
\minote{The output of poseidon are not bytes. How do make this work in the bigger picture?}
\minote{Randomness for the commitment: we can choose to rely on the operating system's entropy. For fault attacks, it does not seem ideal either to have a prf sqeezing all the entropy.}
\subsubsection{Computing the challenge}
\label{sec:fs-challenge}

We introduce a function, that applies to all $\Sigma$-protocols, and takes care of the Fiat-Shamir transform:
\begin{itemize}
  \item $\sigmaprotocol.\challengett(\ctx, \msg, \commitment)$
  return the hash:\[
    \hash(\domsepctx \concat \ctx \concat \sigmaprotocol.\labeltt() \concat \msg \concat  \serialize(\commitment)).
    \]
\end{itemize}
In the above:
\begin{itemize}[label=$-$]
  \item $\ctx$, a 32-byte string identifying the following application-specific data:
  \begin{itemize}
    \item a domain separator, indicating the application name;
    \item local context information, such as:
    session identifiers (to avoid replay attacks), protocol metadata (to avoid hijacking), and optionally a timestamp and some pre-shared randomness (to guarantee freshness of the proof).
  \end{itemize}
  \item $\sigmaprotocol.\labeltt()$, the 32-byte string identifying the statement being proven.
  \item $\msg$, a $\seedlen$ tag, or message, to be attached to the proof.
  Useful when defining signatures. Can be set to zero if not used.
  \item $\serialize(T)$, the serialization of the commitment.
\end{itemize}

We note that the chosen hash functions allow for preprocessing: it is possible to store the partial state and process the commitment.


\subsubsection{Non-interactive proofs}

In a non-interactive protocol, since challenge is computed deterministically from the commitment and the statement, it is not necessary to include it within a proof as it can be deduced in the verification phase.

We define two \emph{public methods} for generating proofs: $\shortproof$, and $\batchableproof$.
Short proofs are the most efficient if the protocol contains at least an AND statement, and the gain in size can be trivially measured as $|\vec \commitment| - \seedlen$.
(Note: the length of the commitment is the length of the statement.)
Batchable proofs are the canonical forms of proofs.
Both provers in the batchable form may raise an exception if the statement is not valid.
Proofs are seen directly as fixed-length bit strings, whose exact length can be inferred from the statement during initialization of the $\Sigma$-protocol.

\subsubsection{Batchable Proofs}

\begin{description}
\item[Prover algorithm.]
The public interface $\sigmaprotocol.\batchableproof( \witness, \ctx, \msg)$:
\begin{enumerate}
\item
   $(\commitment,\proverstatett)\gets\sigmaprotocol.\provercommitment( \witness)$.
\item
$c \gets \sigmaprotocol.\challengett(\ctx, \msg,\commitment)$
\item
   $\response\gets\sigmaprotocol.\proverresponse(\proverstatett,  \challenge)$.
   \item Check that the witness is valid. This can (for instance) be done running \[\sigmaprotocol.\verifiertt(\commitment, \challenge, \response)\]
\jannote{I'd caution against formally requiring a witness-check in the prover algorithm. From experience, this absolutely kills prover performance (basically doubles computation time) and in most scenarios, you trivially get witness-correctness from the larger application (say, I'm just using my Schnorr signature key as always, it won't suddenly become invalid). Maybe that's what you mean with \enquote{for instance}, in which case please clarify for the reader.}
   \item
  Return $\serialize(\commitment) \concat \serialize(\vec \response)$
  \jannote{This concatenation-without-separator seems a bit iffy (is it clear where to separate the concatenated bit string again?). I also feel like it's inconsistent that the prover outputs the concatenation of two serialized objects but the verifier takes as input \enquote{$(\commitment, s)$}. Either establish $(\commitment, s)$-notation (and explain how to serialize tuples somewhere else) or have everyone input/output opaque bit strings}
\end{enumerate}
\item[Verifier algorithm.] The verifier's algorithm $\sigmaprotocol.\batchverifier((\commitment,s), \ctx, \msg)$ works as follows:
\begin{enumerate}
  \item
    $c \gets \sigmaprotocol.\challengett(\ctx, \msg, \commitment)$
  \item
    Return whatever $\sigmaprotocol.\verifiertt(\commitment,\challenge, \response)$ returns.
\end{enumerate}
\begin{remark}{Input validation}{}
The case of batched verification must include a point verification sub-routine that asserts the statement and commitments are in question. Failure to properly check that a commitment is in the group could lead to subgroup attacks~\cite{EC:VanWie96,C:LimLee97} or invalid curve attacks~\cite{C:BieMeyMul00,RSA:BBPV12}.
\end{remark}
\jannote{I might be completely wrong here, but \dots is this remark actually true? Do we need to check that the commitment $\commitment$ is in the right subgroup?
This is a verifier check, so it doesn't impact ZK. 
For soundness, let's say we check that $\commitment$ is on curve (I'd never omit that check), but in the wrong subgroup. Say everything else ($\varphi(\cdot), \statement$) in the right subgroup.
But then the verifier checks $\commitment+c\statement = \varphi(\response)$. If that check is true, then multiplying the equation with $z = \mathit{cofactor}\cdot (\mathit{cofactor}^{-1}\bmod p)$ gives us that $z\cdot \commitment$, which lives in the right subgroup, fulfills the verification equation, too. This generalizes to batch verification.
So it seems like (though I may be overlooking something!?), in soundness proofs, we could just project commitments into the right subgroup and everything would still just work, even if the actual verifier works with elements of the wrong subgroup.
That seems like a significant performance boost not to have to check subgroups for all the $\commitment_i$ in batch verification, but I'm not sure if you want to complicate things.}
\end{description}

\subsubsection{Short Proofs}
\begin{description}
\item[Prover algorithm.]
A new proof $\sigmaprotocol.\shortproof(\witness,\ctx, \msg)$ is built as follows:
\begin{enumerate}
  \item
     $(\commitment,\proverstatett)\gets\sigmaprotocol.\provercommitment(\witness)$.
  \item
   $c \gets \sigmaprotocol.\challengett(\ctx, \msg,  \commitment)$
  \item
     $\vec \response\gets\sigmaprotocol.\proverresponse(\proverstatett,\challenge)$.
    \item Check that the witness is valid. This can (for instance) be done running \[\sigmaprotocol.\verifiertt(\commitment, \challenge, \response)\]
  \item
  Return $\serialize(\challenge) \concat \serialize(\response)$.
\end{enumerate}
\item[Verifier algorithm.] The verifier's algorithm $\sigmaprotocol.\shortverifier( (\challenge, \response), \ctx, \msg)$ works as follows:
\begin{enumerate}
  \item $\commitment \gets \sigmaprotocol.\simcommitmenttt(\challenge, \response)\,.$
  \item $c^* \gets \sigmaprotocol.\challengett(\ctx, \msg, \vec \commitment)$
  \item
  Check whether $\challenge=\challenge^*$.
  Output $\accept$ if this is the case, and $\reject$ otherwise.
\end{enumerate}
\end{description}
\minote{Add de-serialization sub-procedures that may fail}
\minote{Check the inputs to the sub-procedures, like the simulator is not having enough information for recomputing the challenge}

If input parsing fails, an exception should be raised.
If verification fails, an exception should be raised.
Otherwise, the verifier outputs $\pctrue$. Optionally, the implementation can choose to return the parsed statement.





\section{$\Sigma$-protocols on elliptic curves}
\label{sec:instantiation}

\minote{
The $\Sigma$-protocols of this section provide the following guarantees}

\minote{notation for elliptic curves}
The following section now presents concrete instantiations for of $\Sigma$-protocols over elliptic curves.

\begin{remark}{Protocols for residue classes}{}
  Because of their dominance, the presentation in the following focuses on proof goals over elliptic curves, therefore leveraging additive notation.
	For prime-order subgroups of residue classes, all notation needs to be changed to multiplicative, and references to elliptic curves (e.g., $\curvectx$) need to be replaced by their respective counterparts over residue classes.
\end{remark}

\subsection{Ciphersuite Registry}
 We advise for the use of prime-order elliptic curves of size either 256 or 512 bits, depending on the desired security of the upper layers in the protocol\footnote{For instance, proving a DH relation with one fixed group element such as a public key, might expose the protocol to cryptanalytic attacks such as Brown-Gallant~\cite{EPRINT:BroGal04} and Cheon’s attack~\cite{EC:Cheon06}, and some implementations might opt for larger curve sizes. We consider these attacks out of scope for this standardization effort, and believe this analysis should be deferred to the concrete security study of the larger protocol.}.

 \vspace{1em}
 \begin{center}
 \begin{tabular}{llcc}
  \hline
  Curve  & Security Level & Sources \\
  \hline
  \verb|p-521|     & 256& \cite{fips2} \\
  \verb|p-256|     & 128 & \cite{fips2}  \\
  \verb|secp256k1| & 128 & \cite{SECG} \\
  \verb|Ristretto| & 128 & \cite{cfrg-ristretto-decaf} \\
  \verb|BLS12-381| & 128 & \cite{bls12} \\
 \end{tabular}
\end{center}
We denote with $\GG$ the prime-order group of the elliptic curve, with $\FF_p$ the scalar field, and with $G$ the generator of $\GG$.
We assume that all above ciphersuites provide the group operations: check for equality, identity, addition, and scalar multiplication.
\minote{multiscalar multiplication}
In addition, we require the following functions:

\minote{sampling at random}
\begin{itemize}
  \item $\curvectx$, the identifier for the curve displayed in the table above;
  \item \texttt{FromRandomBytes}, taking as input $\seedlen$ and mapping them into an element of the scalar field;
  \item \texttt{Serialize}, taking as input a point in the elliptic curve and returning a fixed-length sequence of bits;
  \item \texttt{Deserialize}, taking a (fixed-length and curve-dependent) sequence of bits and returning an elliptic curve point. This procedure may output an error if the conversion fails.
\end{itemize}

\minote{Add warning that affine points should be used for encoding and decoding}

\subsection{Basic $\Sigma$-Protocols in prime-order groups}\label{sec:basic_sigma}

The protocol presented in the following allow one to prove knowledge of a preimage under an arbitrary \emph{group homomorphism}, which is a mapping between two groups respecting the structure of the groups.
In particular, as will be discussed in \cref{sec:instantiations}, many statements related to discrete logarithms or representations in groups of prime order, can be expressed as statements over group homomorphisms.
For an in-depth discussion of the underlying theory we refer to Cramer~\cite{cramer97}.

\begin{definition}
  For two groups $\GG_1,\GG_2$, a function $\varphi:\GG_1\to\GG_2:x\mapsto\varphi(x)$ is a \emph{(group) homomorphism}, if and only if for all $a,b\in\GG_1$ it holds that $\varphi(a+b)=\varphi(a)+\varphi(b)$.
\end{definition}

\stnote{mention that $\GG_i$ be products of different groups}


\label{sec:sigma-dlog}
We provide a generic template for all $\Sigma$-protocols for statements of the following form over DLOG groups:
\[
  \relation=\set{((\statement_1,\dots,\statement_m),(\witness_1,\dots,\witness_n)) : (\statement_1,\dots,\statement_m)=\varphi(\witness_1,\dots,\witness_n)}
\]
where $\varphi:\FF_p^n\to\GG^m$ is a group homomorphism.

\begin{remark}{Selective disclosure of witnesses}{}
  Note that in the following descriptions, all witnesses are assumed to be kept secret, i.e., none of them is disclosed to the verifier.
	In case it is required to disclose $\witness_j$, as is the case, e.g., in the context of attribute-based credential systems, the relation to be proven can be rewritten as follows:
$$
  \relation'=\set{
	\begin{array}{r}
	((\statement_1',\dots,\statement_m')),(\witness_1,\dots,\witness_{j-1},\witness_{j+1},\dots,\witness_n)) : ~~~~~~~~~~~~\\
	(\statement_1',\dots,\statement_m')=\psi(\witness_1,\dots,\witness_{j-1},\witness_{j+1},\dots,\witness_n)
	\end{array}
	}
$$
  where
	\begin{align*}
    (\statement_1',\dots,\statement_m')                                   &:= (\statement_1,\dots,\statement_m)-\varphi(0,\dots,0,\witness_j,0,\dots,0)\,\text{ and}\\
	  \psi(\witness_1,\dots,\witness_{j-1},\witness_{j+1},\dots,\witness_n) &:= \varphi(\witness_1,\dots,\witness_{j-1},0,\witness_{j+1},\dots,\witness_n)\,.
	\end{align*}

\end{remark}

However, the following \emph{does not define neither the morphism nor the label associated to the protocol}.
These will be defined later in the specific protocols.

 \stnote{which checks are necessary? which values need to be on the curve, etc.?}
\minote{It's maybe dangerously unclear, but I as assuming that all private methods written here have valid elements in the curve, and that validation is up to serialization/deserialization...}
\begin{itemize}
  \item $\dlogsigmaprotocol.\new(\vec\statement)$ internally stores $\vec\statement$.
  \item\label{item:basic:p1}
   $(\vec \commitment, \proverstatett) \gets \dlogsigmaprotocol.\provercommitment(\vec \witness)$ consists of the following steps:
    \begin{enumerate}
      \item\label{item:basic:p1:randomness}
        Sample random elements $\randomness_1,\dots,\randomness_n\sample\FF_p$
      \item
         $\vec \commitment \defeq (\commitment_1,\dots,\commitment_m)\defeq\varphi(\randomness_1,\dots,\randomness_n)$
      \item $\proverstatett\defeq (\randomness_1,\dots,\randomness_n)$
      \item
        Return $(\vec \commitment,\proverstatett)$
    \end{enumerate}
  \item\label{item:basic:p2}
    $\vec \response \gets \dlogsigmaprotocol.\proverresponse(\proverstatett,\challenge)$ proceeds as follows:
    \begin{enumerate}
      \item  $(\randomness_1,\dots,\randomness_n)\defeq \proverstatett$
      \item  $(\witness_1,\dots,\witness_n)\defeq \vec \witness$
      \item
        $c \defeq \frombytes(\challenge)$.
      \item For $i=1,\dots,n$: $\response_i\defeq \randomness_i+\challenge \witness_i$
			\item Return $\vec\response \defeq (\response_1,\dots,\response_n)$.
    \end{enumerate}
  \item $\dlogsigmaprotocol.\labeltt()$ return $\morphismlabel()$.
  \item\label{item:basic:v}
     $\dlogsigmaprotocol.\verifiertt(\vec \commitment,\challenge,\vec \response)$ proceeds as follows:
    \begin{enumerate}
      \item  $(\response_1, \dots, \response_n) \defeq \vec \response$
      \item $(\commitment_1, \dots, \commitment_m) \defeq \vec \commitment$
      \item\label{item:basic:v:checks}
      For $i=1,\dots,n$: check $\response_i\in\FF_p$
      \item
      For $j=1,\dots,m$: check $\commitment_j\in\GG$
      \item Return $\accept$ if $(\commitment_1 + c\statement_1,\dots,\commitment_m + c\statement_m) = \varphi(\response_1,\dots,\response_n)$; $\reject$ otherwise
    \end{enumerate}
  \item $\vec \response \gets \dlogsigmaprotocol.\simresponsett()$:
  \begin{enumerate}
    \item Sample random elements $\response_1,\dots,\response_n\sample\FF_p$
    \item Return $(\response_1, \dots, \response_n)$
  \end{enumerate}
  \item\label{item:basic:sim}
     $\vec \commitment \gets \dlogsigmaprotocol.\simcommitmenttt(c, \vec s)$:
    \begin{enumerate}
      \item
       $(\statement_1,\dots,\statement_m)\defeq \vec \statement$.
      \item\label{item:basic:sim:s}
       $(\response_1,\dots,\response_n) \defeq \vec \response$.
      \item
         $(\commitment_1,\dots,\commitment_m) \defeq \varphi(\response_1,\dots,\response_n) - c(\statement_1,\dots,\statement_m)$.
      \item
        Output $\vec \commitment \defeq(\response_1,\dots,\response_n)$.
    \end{enumerate}
\end{itemize}

\subsection{Advanced: proving linear relations}\label{sec:linear_relations}

While the above protocol allows one to efficiently prove knowledge of a pre-image under a homomorphism, many protocols found in the literature require one to prove relations among witnesses.
  Specifically, they require to prove relations like the following:
\begin{equation*}
\relation=\set{((\statement_1,\dots,\statement_m),(\witness_1,\dots,\witness_n)) :
\begin{array}{c} (\statement_1,\dots,\statement_m)=\varphi(\witness_1,\dots,\witness_n) \\
                  A\cdot(\witness_1,\dots,\witness_n)^\intercal = (b_1,\dots,b_k)^\intercal\end{array}}\,,
\end{equation*}
where the matrix $A\in\FF_p^{k\times n}$ and vector $(b_1,\dots,b_k)\in\FF_p^k$ specify the system of linear equations.

In the following, we sketch how such relations can be translated into relations of the form discussed in \cref{sec:basic_sigma}.
We assume that $A$ is of the following form:
\begin{equation*}
A = \left(\begin{array}{cccccccc}
      a_{11}     & \dots       & a_{1k}    & 1         & 0       & 0     & \dots    & 0\\
      a_{21}     & \dots       & a_{2k}    & 0         & 1       & 0     & \dots    & \vdots\\
      \vdots     &             & \vdots    & \vdots    &         & \vdots&          & 0\\
      \vdots     &             & \vdots    & \vdots    &         & 0     & 1        & 0\\
      a_{k1}     & \dots       & a_{kk}    & 0         & \dots   & \dots & 0        & 1\\
    \end{array}\right)
\end{equation*}
Note that this is without loss of generality.
If the system of linear equations has a different form, the above form can always be achieved using, e.g., Gaussian elimination and re-ordering of witnesses.
Further note that we only need to consider the case where $k<n$, as otherwise the linear equations would uniquely determine the witnesses, which is not desirable in our context.

The following relation $\relation'$ is now equivalent to that specified by $\relation$:
\begin{equation*}
\relation'=\set{((\statement_1,\dots,\statement_m),(\witness_1,\dots,\witness_{n-k})) :
(\statement_1,\dots,\statement_m)=\psi(\witness_1,\dots,\witness_{n-k})}
\end{equation*}
where
\begin{align*}
  \psi(\witness_1,\dots,\witness_{n-k}) &:= \varphi(\witness_1,\dots,\witness_{n-k},-\sum_{i=1}^{n-k}a_{1i}\witness_i,\dots,-\sum_{i=1}^{n-k}a_{ki}\witness_i)\,\text{ and}\\
  (\statement_1',\dots,\statement_m')   &:= (\statement_1,\dots,\statement_m) - \varphi(0,\dots,0,b_1,\dots,b_k)\,.
\end{align*}


\subsection{Instantiations}\label{sec:instantiations}
Let $\GG$ be a group over an elliptic curve with prime order $p$.

\subsubsection{Schnorr signatures}\label{sec:instantiations:schnorr}
Schnorr signatures, also known as Schnorr proofs or DLOG proofs, prove knowledge of the discrete logarithm $w$ of a point $Y$ in base $G$.
That is, they prove knowledge of $w\in\FF_p$ such that $Y=wG$.

\begin{itemize}
  \item $\varphi:\FF_p\to\GG:w\mapsto wG$
  \item $\schnorr.\morphismlabel()$: return:
  \[
    \hash(\schnorrlabel \concat \curvectx \concat \serialize(G) \concat \serialize(\statement))
  \]
\end{itemize}
\stnote{stupid question: should the label (or the curve) have constant length to ensure that label-bits and curve-bits can be clearly seperated?}

For a description of this proof goal in the general case of residue classes, we also refer to~\cite[1.4.1]{zkproof-reference}.

    % \begin{protocol}{Proving knowledge of a discrete logarithm.\\[-2.25em]}{fig:dlog}{bpt}
    %   \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
    %     $\prover\left(\witness,\statement,G\right)$ & & $\verifier\left(\statement,G\right)$  \\
    %     \hline  \\
    %   % -----------------------------P1-------------------------------
    %     $ r\sample\FF_p$ & &\\
    %     $ T \defeq rG$ & & \\
    %     & $\sendr{T}{100}$ \\[2 ex]
    %   % -----------------------------CHALLENGE-------------------------------
    %     & & $c \sample \FF_p$ \\
    %     & $\sendl{c}{100}$ & \\[2 ex]
    %   % -----------------------------P2-------------------------------
    %     $ s \defeq r + cw$\\
    %     & $\sendr{s}{100}$ \\[2 ex]
    %   % -----------------------------V-------------------------------
    %     & & Return $\accept$ iff \\
    %     & & $T + cY = sG$ \\
    %   \end{tabular}
    % \end{protocol}

% For a given challenge $c\in\FF_p$, the simulator chooses $s\sample\FF_p$, and sets $T\gets sG-cY$.
% It then outputs the simulated transcript $(\commitment,\challenge,s)$.

\subsubsection{Discrete logarithm equality}
So-called DLEQ proofs prove equality of the discrete logarithm $w$ of $\statement_1$ in base $G$ and $\statement_2$ in base $H$.

\begin{itemize}
  \item $\varphi:\FF_p\to\GG^2:w\mapsto (wG,wH)$
  \item $\dleq.\morphismlabel()$: return
  \[
    \hash(\dleqlabel \concat \curvectx \concat \serialize(G) \concat \serialize(H) \concat \serialize(\statement_1) \concat \serialize(\statement_2))
  \]
\end{itemize}
    % \begin{protocol}{Proving knowledge of equality of two discrete logarithms (alternative).\\[-2.25em]}{fig:dleq_2}{t}
    %   \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
    %     $\prover \left(\witness,(\statement_1,\statement_2),(G,H) \right)$ & & $\verifier \left((\statement_1,\statement_2),(G,H)\right)$  \\
    %     \hline  \\
    %   % -----------------------------P1-------------------------------
    %     $ r\sample\FF_p$ & &\\
    %     $ \commitment_1 \defeq rG$ & & \\
    %     $ \commitment_2 \defeq rH$ & & \\
    %     & $\sendr{\commitment_1,\commitment_2}{100}$ \\[2 ex]
    %   % -----------------------------CHALLENGE-------------------------------
    %     & & $c \sample \FF_p$ \\
    %     & $\sendl{c}{100}$ & \\[2 ex]
    %   % -----------------------------P2-------------------------------
    %   $s \defeq r + cw $& & \\
    %   & $\sendr{s}{100}$\\[2ex]
    %   % -----------------------------V-------------------------------
    %     & & Return $\accept$ iff \\
    %     & & $\commitment_1 + c\statement_1 = sG$ \\
    %     & & and $\commitment_2 + c\statement_2 = sH$. \\
    %   \end{tabular}
    % \end{protocol}

\subsubsection{Diffie-Hellman}
Let $\GG$ be a group over an elliptic curve with prime order $p$.
Proving knowledge of the exponents of a valid Diffie-Hellman triple means proving knowledge of $\witness_1,\witness_2\in\FF_p$ such that $\statement_1=\witness_1G$, $\statement_2=\witness_2G$, and $\statement_3=\witness_1 \witness_2 G$.
Yet, the mapping $\FF_p^2\to\GG^3:(\witness_1,\witness_2)\mapsto (\witness_1G,\witness_2G,\witness_1\witness_2G)$ is not a homomorphism, and consequently the basic protocol presented before cannot be deployed directly.
However, the required multiplicative relation can be proven by observing that the proof goal is equivalent to $\statement_1=\witness_1G$, $\statement_2=\witness_2G$, and $\statement_3=\witness_2\statement_1$, leading the homomorphism

\begin{itemize}
  \item  $\varphi:\FF_p^2\to\GG^3:(\witness_1,\witness_2)\mapsto(\witness_1G,\witness_2G,\witness_2\statement_1)$
  \item $\dhtt.\morphismlabel()$ return:
  \[
    \hash(\dhlabel \concat \curvectx \concat \serialize(G) \concat \serialize(\statement_0) \concat \serialize(\statement_1))
  \]
\end{itemize}

    % \begin{protocol}{Proving knowledge of representation.\\[-2.25em]}{fig:dh}{t}
    %   \begin{tabular}{@{}l@{\hspace{-3em}}c@{\hspace{-2em}}r@{}}
    %     $\prover\left( (\witness_1,\witness_2),(\statement_1,\statement_2,\statement_3),G)\right)$ & & $\verifier\left((\statement_1,\statement_2,\statement_3),G \right)$  \\
    %     \hline  \\
    %   % -----------------------------P1-------------------------------
    %     $ \randomness_1\sample\FF_p$ & &\\
    %     $ \randomness_2\sample\FF_p$ & &\\
    %     $ \commitment_1 \defeq \randomness_1G$ & & \\
    %     $ \commitment_2 \defeq \randomness_2G$ & & \\
    %     $ \commitment_3 \defeq \randomness_2\statement_1$ & & \\
    %     & $\sendr{\commitment_1,\commitment_2,\commitment_3}{100}$ \\[2 ex]
    %   % -----------------------------CHALLENGE-------------------------------
    %     & & $c \sample \FF_p$ \\
    %     & $\sendl{c}{100}$ & \\[2 ex]
    %   % -----------------------------P2-------------------------------
    %     $ s_1 \defeq \randomness_1 + c\witness_1$\\
    %     $ s_2 \defeq \randomness_2 + c\witness_2$\\
    %     & $\sendr{s_1,s_2}{100}$ \\[2 ex]
    %   % -----------------------------V-------------------------------
    %     & & Return $\accept$ iff \\
    %     & & $\commitment_1 + c\statement_1 = s_1G$ \\
    %     & & $\commitment_2 + c\statement_2 = s_2G$ \\
    %     & & and $\commitment_3 + c\statement_3 = s_2\statement_1$ \\
    %   \end{tabular}
    % \end{protocol}

% For a given challenge $c\in\FF_p$, the simulator chooses $s_1,s_2\sample\FF_p$, and sets $\commitment_1\defeq s_1G -c\statement_1$, $\commitment_2\defeq s_2G-c\statement_2$, and $\commitment_3\defeq s_2\statement_1-c\statement_3$.
% It then outputs the simulated transcript $((\commitment_1,\commitment_2,\commitment_3),\challenge,(s_1,s_2))$.

As shown in this example, and in contrast to linear relations, multiplicative relations among witnesses typically require a reformulation of the proof goal in order to be compatible with the generic protocol presented above.
%We refer, e.g., to Krenn~\cite{krenn12} for generic techniques.


\subsubsection{Representation}\label{sec:instantiations:representation}
Let $\GG$ be a group over an elliptic curve of prime order $p$.
Proving knowledge of a valid opening of a Pedersen commitment means proving knowledge of $\witness_1,\witness_2, \dots, \witness_m\in\FF_p$ such that $Y=\witness_1G_1 + \witness_2G_2 + \dots + \witness_m G_m$.


\begin{itemize}
  \item $\varphi:\FF_p^m\to\GG:(\witness_1,\witness_2, \dots, \witness_m)\mapsto \sum_i \witness_iG_i$
  \item $\rep.\morphismlabel()$ returns
  \[
    \hash(\replabel \concat \curvectx \concat \serialize(G_1) \concat \cdots \concat \serialize(G_m) \concat \serialize(\statement))
  \]
  \minote{length is important to avoid generators swapped with statement}
\end{itemize}
    % \begin{protocol}{Proving knowledge of representation.\\[-2.25em]}{fig:rep}{hbpt}
    %   \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
    %     $\prover \left( (w_1,w_2),Y,(G,H)\right)$ & & $\verifier \left(Y,(G,H)\right)$  \\
    %     \hline  \\
    %   % -----------------------------P1-------------------------------
    %     $ \randomness_1\sample\FF_p$ & &\\
    %     $ \randomness_2\sample\FF_p$ & &\\
    %     $ T \defeq \randomness_1G + \randomness_2H$ & & \\
    %     & $\sendr{T}{100}$ \\[2 ex]
    %   % -----------------------------CHALLENGE-------------------------------
    %     & & $c \sample \FF_p$ \\
    %     & $\sendl{c}{100}$ & \\[2 ex]
    %   % -----------------------------P2-------------------------------
    %     $ s_1 \defeq \randomness_1 + cw_1$\\
    %     $ s_2 \defeq \randomness_2 + cw_2$\\
    %     & $\sendr{s_1,s_2}{100}$ \\[2 ex]
    %   % -----------------------------V-------------------------------
    %     & & Return $\accept$ iff \\
    %     & & $T + cY = s_1G + s_2H$ \\
    %   \end{tabular}
    % \end{protocol}


\begin{example}{Range proofs via bit decomposition}{}
  Let $\GG$ be a cyclic group of prime order $p$, and let $G$ and $H$ be generators of $\GG$, and let $\ell$ be a non-negative integer satisfying $\ell<\log_2 p$.
	Consider the following relation:
  $$
	  \relation_{RANGE} = \set{\left(\statement,(\witness_1,\witness_2))\right)~:~\statement=\witness_1 G +\witness_2 H ~\land~ \witness_1\in[0,2^\ell)}\,.
	$$
	Multiple techniques for proving that a secret witness lies within a certain range, cf. Morais et al.~\cite{range-proof-survey} for a survey.
	We will use the so-called \emph{bit decomposition} approach.

	To do so, the prover computes $\witness_1^{(i)}\in\set{0,1}$ for $i=0,\dots,\ell-1$ such that $\witness_1=\sum_{i=0}^{\ell-1}2^i\witness_1^{(i)}$, and computes commitments to those individual bits, i.e., $\statement^{(i)}=\witness_1^{(i)}G+\witness_2^{(i)}H$ for $\witness_2^{(i)}\sample\FF_p$.
	Furthermore, it sets $\witness^*=\witness_2-\sum_{i=0}^{\ell-1}2^i\witness_2^{(i)}$.

  Assuming that the discrete logarithm problem is hard in $\GG$, the above relation is now equivalent to the following relation:
  \begin{align}
	  \relation_{RANGE}' = \bigg\{\left((\statement,(\statement^{(i)})_{i=0}^{\ell-1}),(\witness_1,\witness_2,(\witness_2^{(i)})_{i=0}^{\ell-1}),\witness^*)\right)~:~ 		\statement=\witness_1 G +\witness_2 H ~\land~ \label{ex:range:preimage}\\
		\statement-\sum_{i=0}^{\ell-1} 2^i\statement^{(i)} = \witness^* H ~\land~  \label{ex:range:equality}\\
		\bigwedge_{i=0}^{\ell-1} \left(\statement^{(i)}=\witness_2^{(i)}H ~\lor~ \statement^{(i)}-G=\witness_2^{(i)}H\right)\bigg\}\,.\label{ex:range:bits}
	\end{align}
	
	It can now be seen that \cref{ex:range:preimage} ensures knowledge of the witnesses $\witness_1$ hidden within $\statement$.
	Furthermore, \cref{ex:range:equality} guarantees that the values hidden within $\statement^{(i)}$ correctly add up to $\witness_1$, i.e., that $\witness_1-\sum_{i=0}^{\ell-1}2^i\witness_1^{(i)}=0$.
  Finally, the two clauses in \cref{ex:range:bits} ensure that each $\statement^{(i)}$ is a commitment to either $0$ or $1$, thus implying the bound on $\witness_1$.
	
	While \cref{ex:range:preimage} can be proven using the protocol from \cref{sec:instantiations:representation}, \cref{ex:range:equality} and \cref{ex:range:bits} can be proven using those from \cref{sec:instantiations:schnorr}.
	The different clauses can finally be composed using nested protocol compositions from \cref{sec:composition}.	
\end{example}

\subsection{Batch verification}

The batchable form can take advantage of the following fact.
Given the single verification equations of the form:
\[
   \commitment_i + \challenge_i Y_i = \sum_j \response_j G_{i,j}
\]
for $i=1, \dots,\ell$,
%(So, $T \in \GG^\ell$, $c \in \FF_p^\ell$ and $s \in \FF_p^{\ell \times m}$ and $\mat G \in \GG^{m \times \ell}$.)
the verifier can sample a random vector of coefficients $\vec a \in \FF_p^\ell$ instead test that:
\[
  \left(\sum_{i=1}^{\ell} a_i \commitment_i\right) + \left(\sum_{i=1}^{\ell} a_i \cdot  \challenge_i \statement_i \right) = \left(\sum_{i=1}^{\ell} a_i \cdot \sum_j \response_j G_{i,j}\right).
\]
If the matrix $G_{i, j}$ of generators has identical rows, by linearity the right-hand side can be computed as a single scalar product.
If the statements $\statement_i$'s have identical rows, by linearity the second term in the equation can be computed as a single scalar product.

In any case, the test can be efficiently implemented as a single multiscalar multiplication, minimizing the number of group operations needed:
\[
  \left(\sum_{i=1}^{\ell} a_i \commitment_i\right) + \left(\sum_{i=1}^{\ell} (a_i \cdot  \challenge_i) \statement_i \right) + \left(\sum_{i=1}^{\ell}\sum_j (-a_i \cdot  \response_j) G_{i,j}\right) = 0.
\]

The random vector $\vec a$ can be \emph{deterministically} generated by fixing $a_1 \defeq 1$ and setting $(a_2, \dots, a_{\ell}) \defeq \prg(\hash(\challenge \concat \vec s))$~\cite{bip-schnorr}.


\section{Additional examples}

Other protocols are not included here but fit within the description
of $\Sigma$-protocols:
\begin{itemize}
\item mpc-in-the-head protocol such as ZKBoo~\cite{USENIX:GiaMadOrl16}
\item one-out-of-many proofs such as~\cite{EC:GroKoh15}
\end{itemize}
\minote{Add example for ring signatures}


\section{Encoding the statement}

Statements in $\Sigma$-protocols take the form of a labeled binary tree:
$\statementnode$ is either:
\begin{itemize}
  \item a label \textsf{AND}, or \textsf{OR}, and two children \textsf{left} and \textsf{right} of type $\statementnode$
  \item a $\statementleaf$ instance. Objects of this type depend on the specific algebraic setting used, and will be treated in \cref{sec:sigma-dlog}.
\end{itemize}
Statements are serialized depth-first.
  There are many different options for serialization that could be considered:
  \begin{itemize}
  \item Concise Binary Object Representation (CBOR) \href{https://datatracker.ietf.org/doc/html/rfc7049}{RFC7049}
    \item The zk proof Reference document provides a serialization document for r1cs~\cite[3.4.2]{zkproof-reference}, but there is nothing in it.
\end{itemize}
The tree is encoded in breadth-first.


\minote{
  This section will be helpful in order to communicate the statement, but
  we are missing a way of translating the statemnt into a tree of provers.
}


\bibliographystyle{alpha}
\bibliography{cryptobib/abbrev3,cryptobib/crypto,additional}

\begin{figure}[b]
\includegraphics[width=\textwidth]{Dinner_Party.png}
\end{figure}
\end{document}